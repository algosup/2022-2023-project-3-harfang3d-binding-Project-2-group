// FABgen output .cpp
// This file is automatically generated, do not modify manually!

#include "fabgen.h"

#include <cstdint>
#include <cassert>
#include <map>
#include <vector>
#include <string>

#define Py_LIMITED_API 0x03020000 // ensure a single build for Python 3.x (with x>2)
#include "Python.h"

static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag);
static void *_type_tag_cast(void *in_T0, uint32_t in_type_tag, uint32_t out_type_tag);

static int64_t _obj_alive_count = 0; // used to prevent the module object from being GCed before an object it created
static PyObject *_module_py_object = NULL;

static inline void _IncModuleRefCount() {
	if (_obj_alive_count == 0)
		Py_INCREF(_module_py_object);
	++_obj_alive_count;
}

static inline void _DecModuleRefCount() {
	--_obj_alive_count;
	if (_obj_alive_count == 0)
		Py_DECREF(_module_py_object);
}

struct type_tag_info {
	uint32_t type_tag;
	const char *c_type;

	bool (*check)(PyObject *o);
	void (*to_c)(PyObject *o, void *obj);
	PyObject *(*from_c)(void *obj, OwnershipPolicy);
};

static type_tag_info *get_bound_type_info(uint32_t type_tag);

typedef struct {
	PyObject_HEAD;

	uint32_t magic_u32; // wrapped_Object marker
	uint32_t type_tag; // wrapped pointer type tag

	void *obj;
	char inline_obj[16]; // storage for inline objects

	void (*on_delete)(void *);
} wrapped_Object;

static void init_wrapped_Object(wrapped_Object *o, uint32_t type_tag, void *obj) {
	o->magic_u32 = 0x46414221;
	o->type_tag = type_tag;

	o->obj = obj;

	o->on_delete = NULL;
}

static inline wrapped_Object *cast_to_wrapped_Object_safe(PyObject *o) {
	wrapped_Object *w = (wrapped_Object *)o;
	if (w->magic_u32 != 0x46414221)
		return NULL;
	return w;
}

static inline wrapped_Object *cast_to_wrapped_Object_unsafe(PyObject *o) { return (wrapped_Object *)o; }

static void wrapped_Object_tp_dealloc(PyObject *self) {
	wrapped_Object *w = cast_to_wrapped_Object_unsafe(self);

	if (w->on_delete)
		w->on_delete(w->obj);

	PyObject_Del(self); // tp_free should be used but PyType_GetSlot is 3.4+

	_DecModuleRefCount();
}

static inline bool CheckArgsTuple(PyObject *args) {
	if (!PyTuple_Check(args)) {
		PyErr_SetString(PyExc_RuntimeError, "invalid arguments object (expected a tuple)");
		return false;
	}
	return true;
}

class PythonValueRef {
public:
	PythonValueRef(PyObject *o_) : o(o_) { Py_XINCREF(o); }
	~PythonValueRef() { Py_XDECREF(o); }

	PyObject *Get() const { return o; }

private:
	PyObject *o;
};

struct gen_type_info {
	uint32_t type_tag;
	const char *c_type;
	const char *bound_name;

	bool (*check)(PyObject *o);
	void (*to_c)(PyObject *o, void *out);
	PyObject *(*from_c)(void *obj, OwnershipPolicy policy);
};

// return a type info from its bound name
gen_type_info *gen_get_bound_type_info(uint32_t type_tag);
// return a type info from its C name
gen_type_info *gen_get_c_type_info(const char *type);
// returns the typetag of a Python object, nullptr if not a Fabgen object
uint32_t gen_get_wrapped_object_type_tag(PyObject *o);

// PyObject * type tag
static uint32_t type_tag_PyObject_ptr = 0xf7b53a96;

// type API for PyObject *
bool gen_check_PyObject_ptr(PyObject *o);
void gen_to_c_PyObject_ptr(PyObject *o, void *obj);
PyObject *gen_from_c_PyObject_ptr(void *obj, OwnershipPolicy);

bool gen_check_PyObject_ptr(PyObject *o) { return true; }
void gen_to_c_PyObject_ptr(PyObject *o, void *obj) { *(void **)obj = o; }
PyObject *gen_from_c_PyObject_ptr(void *o, OwnershipPolicy) { return *(PyObject **)o; }

// bool type tag
static uint32_t type_tag_bool = 0x55813692;

// type API for bool
bool gen_check_bool(PyObject *o);
void gen_to_c_bool(PyObject *o, void *obj);
PyObject *gen_from_c_bool(void *obj, OwnershipPolicy);

bool gen_check_bool(PyObject *o) { return PyBool_Check(o) ? true : false; }
void gen_to_c_bool(PyObject *o, void *obj) { *((bool*)obj) = o == Py_True; }
PyObject *gen_from_c_bool(void *obj, OwnershipPolicy) { return PyBool_FromLong(*((bool*)obj)); }

// char type tag
static uint32_t type_tag_char = 0x8cfe579f;

// type API for char
bool gen_check_char(PyObject *o);
void gen_to_c_char(PyObject *o, void *obj);
PyObject *gen_from_c_char(void *obj, OwnershipPolicy);

bool gen_check_char(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_char(PyObject *o, void *obj) { *((char*)obj) = (char)PyLong_AsLong(o); }
PyObject *gen_from_c_char(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((char*)obj)); }

// short type tag
static uint32_t type_tag_short = 0x8f2890a2;

// type API for short
bool gen_check_short(PyObject *o);
void gen_to_c_short(PyObject *o, void *obj);
PyObject *gen_from_c_short(void *obj, OwnershipPolicy);

bool gen_check_short(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_short(PyObject *o, void *obj) { *((short*)obj) = (short)PyLong_AsLong(o); }
PyObject *gen_from_c_short(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((short*)obj)); }

// int type tag
static uint32_t type_tag_int = 0x1451dab1;

// type API for int
bool gen_check_int(PyObject *o);
void gen_to_c_int(PyObject *o, void *obj);
PyObject *gen_from_c_int(void *obj, OwnershipPolicy);

bool gen_check_int(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_int(PyObject *o, void *obj) { *((int*)obj) = (int)PyLong_AsLong(o); }
PyObject *gen_from_c_int(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((int*)obj)); }

// long type tag
static uint32_t type_tag_long = 0x3b97a968;

// type API for long
bool gen_check_long(PyObject *o);
void gen_to_c_long(PyObject *o, void *obj);
PyObject *gen_from_c_long(void *obj, OwnershipPolicy);

bool gen_check_long(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_long(PyObject *o, void *obj) { *((long*)obj) = (long)PyLong_AsLong(o); }
PyObject *gen_from_c_long(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((long*)obj)); }

// int8_t type tag
static uint32_t type_tag_int8_t = 0x1c554140;

// type API for int8_t
bool gen_check_int8_t(PyObject *o);
void gen_to_c_int8_t(PyObject *o, void *obj);
PyObject *gen_from_c_int8_t(void *obj, OwnershipPolicy);

bool gen_check_int8_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_int8_t(PyObject *o, void *obj) { *((int8_t*)obj) = (int8_t)PyLong_AsLong(o); }
PyObject *gen_from_c_int8_t(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((int8_t*)obj)); }

// int16_t type tag
static uint32_t type_tag_int16_t = 0xbfd40c35;

// type API for int16_t
bool gen_check_int16_t(PyObject *o);
void gen_to_c_int16_t(PyObject *o, void *obj);
PyObject *gen_from_c_int16_t(void *obj, OwnershipPolicy);

bool gen_check_int16_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_int16_t(PyObject *o, void *obj) { *((int16_t*)obj) = (int16_t)PyLong_AsLong(o); }
PyObject *gen_from_c_int16_t(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((int16_t*)obj)); }

// int32_t type tag
static uint32_t type_tag_int32_t = 0x12d46c62;

// type API for int32_t
bool gen_check_int32_t(PyObject *o);
void gen_to_c_int32_t(PyObject *o, void *obj);
PyObject *gen_from_c_int32_t(void *obj, OwnershipPolicy);

bool gen_check_int32_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_int32_t(PyObject *o, void *obj) { *((int32_t*)obj) = (int32_t)PyLong_AsLong(o); }
PyObject *gen_from_c_int32_t(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((int32_t*)obj)); }

// char16_t type tag
static uint32_t type_tag_char16_t = 0xc19fe7bb;

// type API for char16_t
bool gen_check_char16_t(PyObject *o);
void gen_to_c_char16_t(PyObject *o, void *obj);
PyObject *gen_from_c_char16_t(void *obj, OwnershipPolicy);

bool gen_check_char16_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_char16_t(PyObject *o, void *obj) { *((char16_t*)obj) = (char16_t)PyLong_AsLong(o); }
PyObject *gen_from_c_char16_t(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((char16_t*)obj)); }

// char32_t type tag
static uint32_t type_tag_char32_t = 0x6c9f87ec;

// type API for char32_t
bool gen_check_char32_t(PyObject *o);
void gen_to_c_char32_t(PyObject *o, void *obj);
PyObject *gen_from_c_char32_t(void *obj, OwnershipPolicy);

bool gen_check_char32_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_char32_t(PyObject *o, void *obj) { *((char32_t*)obj) = (char32_t)PyLong_AsLong(o); }
PyObject *gen_from_c_char32_t(void *obj, OwnershipPolicy) { return PyLong_FromLong(*((char32_t*)obj)); }

// unsigned char type tag
static uint32_t type_tag_unsigned_char = 0x838f8d38;

// type API for unsigned char
bool gen_check_unsigned_char(PyObject *o);
void gen_to_c_unsigned_char(PyObject *o, void *obj);
PyObject *gen_from_c_unsigned_char(void *obj, OwnershipPolicy);

bool gen_check_unsigned_char(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_unsigned_char(PyObject *o, void *obj) { *((unsigned char*)obj) = (unsigned char)PyLong_AsUnsignedLong(o); }
PyObject *gen_from_c_unsigned_char(void *obj, OwnershipPolicy) { return PyLong_FromUnsignedLong(*((unsigned char*)obj)); }

// unsigned short type tag
static uint32_t type_tag_unsigned_short = 0xc795d733;

// type API for unsigned short
bool gen_check_unsigned_short(PyObject *o);
void gen_to_c_unsigned_short(PyObject *o, void *obj);
PyObject *gen_from_c_unsigned_short(void *obj, OwnershipPolicy);

bool gen_check_unsigned_short(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_unsigned_short(PyObject *o, void *obj) { *((unsigned short*)obj) = (unsigned short)PyLong_AsUnsignedLong(o); }
PyObject *gen_from_c_unsigned_short(void *obj, OwnershipPolicy) { return PyLong_FromUnsignedLong(*((unsigned short*)obj)); }

// unsigned int type tag
static uint32_t type_tag_unsigned_int = 0x657249f8;

// type API for unsigned int
bool gen_check_unsigned_int(PyObject *o);
void gen_to_c_unsigned_int(PyObject *o, void *obj);
PyObject *gen_from_c_unsigned_int(void *obj, OwnershipPolicy);

bool gen_check_unsigned_int(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_unsigned_int(PyObject *o, void *obj) { *((unsigned int*)obj) = (unsigned int)PyLong_AsUnsignedLong(o); }
PyObject *gen_from_c_unsigned_int(void *obj, OwnershipPolicy) { return PyLong_FromUnsignedLong(*((unsigned int*)obj)); }

// unsigned long type tag
static uint32_t type_tag_unsigned_long = 0x34e673cf;

// type API for unsigned long
bool gen_check_unsigned_long(PyObject *o);
void gen_to_c_unsigned_long(PyObject *o, void *obj);
PyObject *gen_from_c_unsigned_long(void *obj, OwnershipPolicy);

bool gen_check_unsigned_long(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_unsigned_long(PyObject *o, void *obj) { *((unsigned long*)obj) = (unsigned long)PyLong_AsUnsignedLong(o); }
PyObject *gen_from_c_unsigned_long(void *obj, OwnershipPolicy) { return PyLong_FromUnsignedLong(*((unsigned long*)obj)); }

// uint8_t type tag
static uint32_t type_tag_uint8_t = 0x8eabc011;

// type API for uint8_t
bool gen_check_uint8_t(PyObject *o);
void gen_to_c_uint8_t(PyObject *o, void *obj);
PyObject *gen_from_c_uint8_t(void *obj, OwnershipPolicy);

bool gen_check_uint8_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_uint8_t(PyObject *o, void *obj) { *((uint8_t*)obj) = (uint8_t)PyLong_AsUnsignedLong(o); }
PyObject *gen_from_c_uint8_t(void *obj, OwnershipPolicy) { return PyLong_FromUnsignedLong(*((uint8_t*)obj)); }

// uint16_t type tag
static uint32_t type_tag_uint16_t = 0xa32a93d6;

// type API for uint16_t
bool gen_check_uint16_t(PyObject *o);
void gen_to_c_uint16_t(PyObject *o, void *obj);
PyObject *gen_from_c_uint16_t(void *obj, OwnershipPolicy);

bool gen_check_uint16_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_uint16_t(PyObject *o, void *obj) { *((uint16_t*)obj) = (uint16_t)PyLong_AsUnsignedLong(o); }
PyObject *gen_from_c_uint16_t(void *obj, OwnershipPolicy) { return PyLong_FromUnsignedLong(*((uint16_t*)obj)); }

// uint32_t type tag
static uint32_t type_tag_uint32_t = 0xe2af381;

// type API for uint32_t
bool gen_check_uint32_t(PyObject *o);
void gen_to_c_uint32_t(PyObject *o, void *obj);
PyObject *gen_from_c_uint32_t(void *obj, OwnershipPolicy);

bool gen_check_uint32_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_uint32_t(PyObject *o, void *obj) { *((uint32_t*)obj) = (uint32_t)PyLong_AsUnsignedLong(o); }
PyObject *gen_from_c_uint32_t(void *obj, OwnershipPolicy) { return PyLong_FromUnsignedLong(*((uint32_t*)obj)); }

// int64_t type tag
static uint32_t type_tag_int64_t = 0x2187e0e2;

// type API for int64_t
bool gen_check_int64_t(PyObject *o);
void gen_to_c_int64_t(PyObject *o, void *obj);
PyObject *gen_from_c_int64_t(void *obj, OwnershipPolicy);

bool gen_check_int64_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_int64_t(PyObject *o, void *obj) { *((int64_t*)obj) = PyLong_AsLongLong(o); }
PyObject *gen_from_c_int64_t(void *obj, OwnershipPolicy) { return PyLong_FromLongLong(*((int64_t*)obj)); }

// uint64_t type tag
static uint32_t type_tag_uint64_t = 0x3d797f01;

// type API for uint64_t
bool gen_check_uint64_t(PyObject *o);
void gen_to_c_uint64_t(PyObject *o, void *obj);
PyObject *gen_from_c_uint64_t(void *obj, OwnershipPolicy);

bool gen_check_uint64_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_uint64_t(PyObject *o, void *obj) { *((uint64_t*)obj) = PyLong_AsUnsignedLongLong(o); }
PyObject *gen_from_c_uint64_t(void *obj, OwnershipPolicy) { return PyLong_FromUnsignedLongLong(*((uint64_t*)obj)); }

// intptr_t type tag
static uint32_t type_tag_intptr_t = 0xc10d8312;

// type API for intptr_t
bool gen_check_intptr_t(PyObject *o);
void gen_to_c_intptr_t(PyObject *o, void *obj);
PyObject *gen_from_c_intptr_t(void *obj, OwnershipPolicy);

bool gen_check_intptr_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_intptr_t(PyObject *o, void *obj) { *((intptr_t*)obj) = (intptr_t)PyLong_AsVoidPtr(o); }
PyObject *gen_from_c_intptr_t(void *obj, OwnershipPolicy) { return PyLong_FromVoidPtr((void *)(*((intptr_t*)obj))); }

// size_t type tag
static uint32_t type_tag_size_t = 0x8883767d;

// type API for size_t
bool gen_check_size_t(PyObject *o);
void gen_to_c_size_t(PyObject *o, void *obj);
PyObject *gen_from_c_size_t(void *obj, OwnershipPolicy);

bool gen_check_size_t(PyObject *o) { return PyLong_CheckExact(o) ? true : false; }
void gen_to_c_size_t(PyObject *o, void *obj) { *((size_t*)obj) = PyLong_AsSize_t(o); }
PyObject *gen_from_c_size_t(void *obj, OwnershipPolicy) { return PyLong_FromSize_t(*((size_t*)obj)); }

// float type tag
static uint32_t type_tag_float = 0xc9a55e95;

// type API for float
bool gen_check_float(PyObject *o);
void gen_to_c_float(PyObject *o, void *obj);
PyObject *gen_from_c_float(void *obj, OwnershipPolicy);

bool gen_check_float(PyObject *o) { return PyFloat_Check(o) || PyLong_Check(o) ? true : false; }
void gen_to_c_float(PyObject *o, void *obj) { *((float*)obj) = (float)PyFloat_AsDouble(o); }
PyObject *gen_from_c_float(void *obj, OwnershipPolicy) { return PyFloat_FromDouble(*((float*)obj)); }

// double type tag
static uint32_t type_tag_double = 0xdae7f2ef;

// type API for double
bool gen_check_double(PyObject *o);
void gen_to_c_double(PyObject *o, void *obj);
PyObject *gen_from_c_double(void *obj, OwnershipPolicy);

bool gen_check_double(PyObject *o) { return PyFloat_Check(o) || PyLong_Check(o) ? true : false; }
void gen_to_c_double(PyObject *o, void *obj) { *((double*)obj) = (double)PyFloat_AsDouble(o); }
PyObject *gen_from_c_double(void *obj, OwnershipPolicy) { return PyFloat_FromDouble(*((double*)obj)); }

// const char * type tag
static uint32_t type_tag_const_char_ptr = 0x682eed33;

// type API for const char *
struct storage_const_char_ptr;
bool gen_check_const_char_ptr(PyObject *o);
void gen_to_c_const_char_ptr(PyObject *o, void *obj, storage_const_char_ptr &storage);
PyObject *gen_from_c_const_char_ptr(void *obj, OwnershipPolicy);

struct storage_const_char_ptr { std::string s; };
bool gen_check_const_char_ptr(PyObject *o) { return PyUnicode_Check(o) ? true : false; }
void gen_to_c_const_char_ptr(PyObject *o, void *obj, storage_const_char_ptr &storage) {
	PyObject *utf8_pyobj = PyUnicode_AsUTF8String(o);
	storage.s = PyBytes_AsString(utf8_pyobj);
	*((const char **)obj) = storage.s.data();
	Py_DECREF(utf8_pyobj);
}
PyObject *gen_from_c_const_char_ptr(void *obj, OwnershipPolicy) { return PyUnicode_FromString(*((const char **)obj)); }

// std::string type tag
static uint32_t type_tag_string = 0x9ebeb2a9;

// type API for std::string
bool gen_check_string(PyObject *o);
void gen_to_c_string(PyObject *o, void *obj);
PyObject *gen_from_c_string(void *obj, OwnershipPolicy);

bool gen_check_string(PyObject *o) { return PyUnicode_Check(o) ? true : false; }
void gen_to_c_string(PyObject *o, void *obj) {
PyObject *utf8_pyobj = PyUnicode_AsUTF8String(o);
*((std::string*)obj) = PyBytes_AsString(utf8_pyobj);
Py_DECREF(utf8_pyobj);
}
PyObject *gen_from_c_string(void *obj, OwnershipPolicy) { return PyUnicode_FromString(((std::string*)obj)->c_str()); }

// FloatValue type tag
static uint32_t type_tag_FloatValue = 0x6454579d;

// type API for FloatValue
bool gen_check_FloatValue(PyObject *o);
void gen_to_c_FloatValue(PyObject *o, void *obj);
PyObject *gen_from_c_FloatValue(void *obj, OwnershipPolicy);

// FloatValue constructor
static PyObject *gen_construct_FloatValue(PyObject *self, PyObject *args) {
	if (!CheckArgsTuple(args))
		return NULL;
	Py_ssize_t arg_count = PyTuple_Size(args);

	PyObject *arg_pyobj[1];
	for (Py_ssize_t _i = 0; _i < arg_count && _i < 1; ++_i)
		arg_pyobj[_i] = PyTuple_GetItem(args, _i);

	if (arg_count == 0) {
FloatValue * rval = new FloatValue();
PyObject *rval_out;
if (!rval) {
Py_INCREF(Py_None);
rval_out = Py_None;
} else {
rval_out = gen_from_c_FloatValue((void *)rval, Owning);
}
return rval_out;
	} else 	if (arg_count == 1) {
		if (gen_check_float(arg_pyobj[0])) {
float arg0;
gen_to_c_float(arg_pyobj[0], (void *)&arg0);
FloatValue * rval = new FloatValue(arg0);
PyObject *rval_out;
if (!rval) {
Py_INCREF(Py_None);
rval_out = Py_None;
} else {
rval_out = gen_from_c_FloatValue((void *)rval, Owning);
}
return rval_out;
		} else {
PyErr_SetString(PyExc_RuntimeError, "incorrect type for argument 1 to FloatValue constructor, expected float value");
		}
	} else {
PyErr_SetString(PyExc_RuntimeError, "incorrect number of arguments to FloatValue constructor");
	}
	return NULL;
}

// method Get of FloatValue
static PyObject *gen_method_Get_of_FloatValue(PyObject *self, PyObject *args) {
	if (!CheckArgsTuple(args))
		return NULL;
	Py_ssize_t arg_count = PyTuple_Size(args);

	if (arg_count == 0) {
	FloatValue * _self;
	gen_to_c_FloatValue(self, (void *)&_self);
float rval = _self->Get();
PyObject *rval_out;
rval_out = gen_from_c_float((void *)&rval, Copy);
return rval_out;
	} else {
PyErr_SetString(PyExc_RuntimeError, "incorrect number of arguments to method Get of FloatValue");
	}
	return NULL;
}

// method Set of FloatValue
static PyObject *gen_method_Set_of_FloatValue(PyObject *self, PyObject *args) {
	if (!CheckArgsTuple(args))
		return NULL;
	Py_ssize_t arg_count = PyTuple_Size(args);

	PyObject *arg_pyobj[1];
	for (Py_ssize_t _i = 0; _i < arg_count && _i < 1; ++_i)
		arg_pyobj[_i] = PyTuple_GetItem(args, _i);

	if (arg_count == 1) {
		if (gen_check_float(arg_pyobj[0])) {
	FloatValue * _self;
	gen_to_c_FloatValue(self, (void *)&_self);
float arg0;
gen_to_c_float(arg_pyobj[0], (void *)&arg0);
_self->Set(arg0);
Py_INCREF(Py_None);
return Py_None;
		} else {
PyErr_SetString(PyExc_RuntimeError, "incorrect type for argument 1 to method Set of FloatValue, expected float value");
		}
	} else {
PyErr_SetString(PyExc_RuntimeError, "incorrect number of arguments to method Set of FloatValue");
	}
	return NULL;
}

// + operator of FloatValue
static PyObject *gen_add_operator_of_FloatValue(PyObject *o1, PyObject *o2) {
if (!gen_check_FloatValue(o1)) {
PyErr_SetString(PyExc_RuntimeError, "incorrect type for argument 0 to + operator of FloatValue, expected FloatValue");
return NULL;
}

	if (gen_check_FloatValue(o2)) {
	FloatValue * _self;
	gen_to_c_FloatValue(o1, (void *)&_self);
FloatValue * arg0;
gen_to_c_FloatValue(o2, (void *)&arg0);
FloatValue rval = *_self + *arg0;
PyObject *rval_out;
rval_out = gen_from_c_FloatValue((void *)&rval, Copy);
return rval_out;
	} else {
PyErr_SetString(PyExc_RuntimeError, "incorrect type for argument 1 to + operator of FloatValue, expected FloatValue b");
	}
	return NULL;
}

// type FloatValue
static PyObject *FloatValue_type;

static PyObject *FloatValue_tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds) {
	return gen_construct_FloatValue(NULL, args);
}

static PyGetSetDef FloatValue_tp_getset[] = {
	{NULL} /* Sentinel */
};

static PyMethodDef FloatValue_tp_methods[] = {
	{(char *)"Get", (PyCFunction)gen_method_Get_of_FloatValue, METH_VARARGS},
	{(char *)"Set", (PyCFunction)gen_method_Set_of_FloatValue, METH_VARARGS},
	{NULL} /* Sentinel */
};

static PyObject *FloatValue_default_Py_EQ(PyObject *o1, PyObject *o2) {
	wrapped_Object *w1 = cast_to_wrapped_Object_safe(o1);
	wrapped_Object *w2 = cast_to_wrapped_Object_safe(o2);

	if (!w1 || !w2 || w1->type_tag != w2->type_tag) {
		Py_RETURN_FALSE;
	}

	if (!(w1->obj == w2->obj)) {
		Py_RETURN_FALSE;
	}

	Py_RETURN_TRUE;
}
static PyObject *FloatValue_default_Py_NE(PyObject *o1, PyObject *o2) {
	wrapped_Object *w1 = cast_to_wrapped_Object_safe(o1);
	wrapped_Object *w2 = cast_to_wrapped_Object_safe(o2);

	if (!w1 || !w2 || w1->type_tag != w2->type_tag) {
		Py_RETURN_FALSE;
	}

	if (!(w1->obj != w2->obj)) {
		Py_RETURN_FALSE;
	}

	Py_RETURN_TRUE;
}
static PyObject *FloatValue_tp_richcompare(PyObject *o1, PyObject *o2, int op) {
	if (op == Py_EQ) return FloatValue_default_Py_EQ(o1, o2);
	if (op == Py_NE) return FloatValue_default_Py_NE(o1, o2);
	Py_RETURN_NOTIMPLEMENTED;
}

static PyType_Slot FloatValue_slots[] = {
	{Py_tp_new, (void *)&FloatValue_tp_new},
	{Py_tp_doc, (void *)""},
	{Py_tp_dealloc, (void *)&wrapped_Object_tp_dealloc},
	{Py_tp_getset, (void *)&FloatValue_tp_getset},
	{Py_tp_methods, (void *)&FloatValue_tp_methods},
	{Py_tp_richcompare, (void *)&FloatValue_tp_richcompare},
	{Py_nb_add, (void *)&gen_add_operator_of_FloatValue},
	{0, NULL}
};

static PyType_Spec FloatValue_spec = {
	"FloatValue", /* name */
	sizeof(wrapped_Object), /* basicsize */
	0, /* itemsize*/
	Py_TPFLAGS_DEFAULT, /* flags */
	FloatValue_slots
};

static void delete_FloatValue(void *o) { delete (FloatValue *)o; }

bool gen_check_FloatValue(PyObject *o) {
	wrapped_Object *w = cast_to_wrapped_Object_safe(o);
	if (!w)
		return false;
	return _type_tag_can_cast(w->type_tag, type_tag_FloatValue);
}

void gen_to_c_FloatValue(PyObject *o, void *obj) {
	wrapped_Object *w = cast_to_wrapped_Object_unsafe(o);
	*(void **)obj = _type_tag_cast(w->obj, w->type_tag, type_tag_FloatValue);
}

PyObject *gen_from_c_FloatValue(void *obj, OwnershipPolicy own) {
	wrapped_Object *pyobj = PyObject_New(wrapped_Object, (PyTypeObject *)FloatValue_type);
	if (own == Copy) {
		obj = new FloatValue(*(FloatValue *)obj);
	}
	init_wrapped_Object(pyobj, type_tag_FloatValue, obj);
	if (own != NonOwning)
		pyobj->on_delete = &delete_FloatValue;

	_IncModuleRefCount();
	return (PyObject *)pyobj;
}


// Module definitions starts here.

// type_tag based cast system
static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag) {
	if (out_type_tag == in_type_tag)
		return true;

	
	return false;
}

static void *_type_tag_cast(void *in_ptr, uint32_t in_type_tag, uint32_t out_type_tag) {
	if (out_type_tag == in_type_tag)
		return in_ptr;

	void *out_ptr = NULL;
	

	return out_ptr;
}

size_t gen_link_binding(gen_type_info *(*get_c_type_info)(const char *type)) {
	size_t unresolved = 0;

	return unresolved;
}

static PyMethodDef float_value_Methods[] = {
	{NULL, NULL, 0, NULL} /* Sentinel */
};

void PyFree_float_value(void *) {
	// custom free code
}

static struct PyModuleDef float_value_module = {
	PyModuleDef_HEAD_INIT,
	"float_value", /* name of module */
	"", /* module documentation, may be NULL */
	-1, /* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */
	float_value_Methods,
	NULL, /* m_slots */
	NULL, /* m_traverse */
	NULL, /* m_clear */
	&PyFree_float_value /* m_free */
};

// Note: Types using a storage class for conversion are not listed here.
static std::map<uint32_t, gen_type_info> __type_tag_infos;

static void __initialize_type_tag_infos() {
	__type_tag_infos[type_tag_PyObject_ptr] = {type_tag_PyObject_ptr, "PyObject *", "PyObject_ptr", gen_check_PyObject_ptr, gen_to_c_PyObject_ptr, gen_from_c_PyObject_ptr};
	__type_tag_infos[type_tag_bool] = {type_tag_bool, "bool", "bool", gen_check_bool, gen_to_c_bool, gen_from_c_bool};
	__type_tag_infos[type_tag_char] = {type_tag_char, "char", "char", gen_check_char, gen_to_c_char, gen_from_c_char};
	__type_tag_infos[type_tag_short] = {type_tag_short, "short", "short", gen_check_short, gen_to_c_short, gen_from_c_short};
	__type_tag_infos[type_tag_int] = {type_tag_int, "int", "int", gen_check_int, gen_to_c_int, gen_from_c_int};
	__type_tag_infos[type_tag_long] = {type_tag_long, "long", "long", gen_check_long, gen_to_c_long, gen_from_c_long};
	__type_tag_infos[type_tag_int8_t] = {type_tag_int8_t, "int8_t", "int8_t", gen_check_int8_t, gen_to_c_int8_t, gen_from_c_int8_t};
	__type_tag_infos[type_tag_int16_t] = {type_tag_int16_t, "int16_t", "int16_t", gen_check_int16_t, gen_to_c_int16_t, gen_from_c_int16_t};
	__type_tag_infos[type_tag_int32_t] = {type_tag_int32_t, "int32_t", "int32_t", gen_check_int32_t, gen_to_c_int32_t, gen_from_c_int32_t};
	__type_tag_infos[type_tag_char16_t] = {type_tag_char16_t, "char16_t", "char16_t", gen_check_char16_t, gen_to_c_char16_t, gen_from_c_char16_t};
	__type_tag_infos[type_tag_char32_t] = {type_tag_char32_t, "char32_t", "char32_t", gen_check_char32_t, gen_to_c_char32_t, gen_from_c_char32_t};
	__type_tag_infos[type_tag_unsigned_char] = {type_tag_unsigned_char, "unsigned char", "unsigned_char", gen_check_unsigned_char, gen_to_c_unsigned_char, gen_from_c_unsigned_char};
	__type_tag_infos[type_tag_unsigned_short] = {type_tag_unsigned_short, "unsigned short", "unsigned_short", gen_check_unsigned_short, gen_to_c_unsigned_short, gen_from_c_unsigned_short};
	__type_tag_infos[type_tag_unsigned_int] = {type_tag_unsigned_int, "unsigned int", "unsigned_int", gen_check_unsigned_int, gen_to_c_unsigned_int, gen_from_c_unsigned_int};
	__type_tag_infos[type_tag_unsigned_long] = {type_tag_unsigned_long, "unsigned long", "unsigned_long", gen_check_unsigned_long, gen_to_c_unsigned_long, gen_from_c_unsigned_long};
	__type_tag_infos[type_tag_uint8_t] = {type_tag_uint8_t, "uint8_t", "uint8_t", gen_check_uint8_t, gen_to_c_uint8_t, gen_from_c_uint8_t};
	__type_tag_infos[type_tag_uint16_t] = {type_tag_uint16_t, "uint16_t", "uint16_t", gen_check_uint16_t, gen_to_c_uint16_t, gen_from_c_uint16_t};
	__type_tag_infos[type_tag_uint32_t] = {type_tag_uint32_t, "uint32_t", "uint32_t", gen_check_uint32_t, gen_to_c_uint32_t, gen_from_c_uint32_t};
	__type_tag_infos[type_tag_int64_t] = {type_tag_int64_t, "int64_t", "int64_t", gen_check_int64_t, gen_to_c_int64_t, gen_from_c_int64_t};
	__type_tag_infos[type_tag_uint64_t] = {type_tag_uint64_t, "uint64_t", "uint64_t", gen_check_uint64_t, gen_to_c_uint64_t, gen_from_c_uint64_t};
	__type_tag_infos[type_tag_intptr_t] = {type_tag_intptr_t, "intptr_t", "intptr_t", gen_check_intptr_t, gen_to_c_intptr_t, gen_from_c_intptr_t};
	__type_tag_infos[type_tag_size_t] = {type_tag_size_t, "size_t", "size_t", gen_check_size_t, gen_to_c_size_t, gen_from_c_size_t};
	__type_tag_infos[type_tag_float] = {type_tag_float, "float", "float", gen_check_float, gen_to_c_float, gen_from_c_float};
	__type_tag_infos[type_tag_double] = {type_tag_double, "double", "double", gen_check_double, gen_to_c_double, gen_from_c_double};
	__type_tag_infos[type_tag_string] = {type_tag_string, "std::string", "string", gen_check_string, gen_to_c_string, gen_from_c_string};
	__type_tag_infos[type_tag_FloatValue] = {type_tag_FloatValue, "FloatValue", "FloatValue", gen_check_FloatValue, gen_to_c_FloatValue, gen_from_c_FloatValue};
};

gen_type_info *gen_get_bound_type_info(uint32_t type_tag) {
	auto i = __type_tag_infos.find(type_tag);
	return i == __type_tag_infos.end() ? nullptr : &i->second;
}

static std::map<std::string, gen_type_info> __type_infos;

static void __initialize_type_infos() {
	__type_infos["PyObject *"] = {type_tag_PyObject_ptr, "PyObject *", "PyObject_ptr", gen_check_PyObject_ptr, gen_to_c_PyObject_ptr, gen_from_c_PyObject_ptr};
	__type_infos["bool"] = {type_tag_bool, "bool", "bool", gen_check_bool, gen_to_c_bool, gen_from_c_bool};
	__type_infos["char"] = {type_tag_char, "char", "char", gen_check_char, gen_to_c_char, gen_from_c_char};
	__type_infos["short"] = {type_tag_short, "short", "short", gen_check_short, gen_to_c_short, gen_from_c_short};
	__type_infos["int"] = {type_tag_int, "int", "int", gen_check_int, gen_to_c_int, gen_from_c_int};
	__type_infos["long"] = {type_tag_long, "long", "long", gen_check_long, gen_to_c_long, gen_from_c_long};
	__type_infos["int8_t"] = {type_tag_int8_t, "int8_t", "int8_t", gen_check_int8_t, gen_to_c_int8_t, gen_from_c_int8_t};
	__type_infos["int16_t"] = {type_tag_int16_t, "int16_t", "int16_t", gen_check_int16_t, gen_to_c_int16_t, gen_from_c_int16_t};
	__type_infos["int32_t"] = {type_tag_int32_t, "int32_t", "int32_t", gen_check_int32_t, gen_to_c_int32_t, gen_from_c_int32_t};
	__type_infos["char16_t"] = {type_tag_char16_t, "char16_t", "char16_t", gen_check_char16_t, gen_to_c_char16_t, gen_from_c_char16_t};
	__type_infos["char32_t"] = {type_tag_char32_t, "char32_t", "char32_t", gen_check_char32_t, gen_to_c_char32_t, gen_from_c_char32_t};
	__type_infos["unsigned char"] = {type_tag_unsigned_char, "unsigned char", "unsigned_char", gen_check_unsigned_char, gen_to_c_unsigned_char, gen_from_c_unsigned_char};
	__type_infos["unsigned short"] = {type_tag_unsigned_short, "unsigned short", "unsigned_short", gen_check_unsigned_short, gen_to_c_unsigned_short, gen_from_c_unsigned_short};
	__type_infos["unsigned int"] = {type_tag_unsigned_int, "unsigned int", "unsigned_int", gen_check_unsigned_int, gen_to_c_unsigned_int, gen_from_c_unsigned_int};
	__type_infos["unsigned long"] = {type_tag_unsigned_long, "unsigned long", "unsigned_long", gen_check_unsigned_long, gen_to_c_unsigned_long, gen_from_c_unsigned_long};
	__type_infos["uint8_t"] = {type_tag_uint8_t, "uint8_t", "uint8_t", gen_check_uint8_t, gen_to_c_uint8_t, gen_from_c_uint8_t};
	__type_infos["uint16_t"] = {type_tag_uint16_t, "uint16_t", "uint16_t", gen_check_uint16_t, gen_to_c_uint16_t, gen_from_c_uint16_t};
	__type_infos["uint32_t"] = {type_tag_uint32_t, "uint32_t", "uint32_t", gen_check_uint32_t, gen_to_c_uint32_t, gen_from_c_uint32_t};
	__type_infos["int64_t"] = {type_tag_int64_t, "int64_t", "int64_t", gen_check_int64_t, gen_to_c_int64_t, gen_from_c_int64_t};
	__type_infos["uint64_t"] = {type_tag_uint64_t, "uint64_t", "uint64_t", gen_check_uint64_t, gen_to_c_uint64_t, gen_from_c_uint64_t};
	__type_infos["intptr_t"] = {type_tag_intptr_t, "intptr_t", "intptr_t", gen_check_intptr_t, gen_to_c_intptr_t, gen_from_c_intptr_t};
	__type_infos["size_t"] = {type_tag_size_t, "size_t", "size_t", gen_check_size_t, gen_to_c_size_t, gen_from_c_size_t};
	__type_infos["float"] = {type_tag_float, "float", "float", gen_check_float, gen_to_c_float, gen_from_c_float};
	__type_infos["double"] = {type_tag_double, "double", "double", gen_check_double, gen_to_c_double, gen_from_c_double};
	__type_infos["std::string"] = {type_tag_string, "std::string", "string", gen_check_string, gen_to_c_string, gen_from_c_string};
	__type_infos["FloatValue"] = {type_tag_FloatValue, "FloatValue", "FloatValue", gen_check_FloatValue, gen_to_c_FloatValue, gen_from_c_FloatValue};
};


gen_type_info *gen_get_c_type_info(const char *type) {
	auto i = __type_infos.find(type);
	return i == __type_infos.end() ? nullptr : &i->second;
}

uint32_t gen_get_wrapped_object_type_tag(PyObject *o) {
	auto w = cast_to_wrapped_Object_safe(o);
	return w ? w->type_tag : 0;
}

PyMODINIT_FUNC PyInit_float_value(void) {
	// custom initialization code
	// initialize type info structures
	__initialize_type_tag_infos();
	__initialize_type_infos();


	PyObject *m = PyModule_Create(&float_value_module);
	if (m == NULL)
		return NULL;

	_module_py_object = m;
	// custom types finalization
	FloatValue_type = PyType_FromSpec(&FloatValue_spec);
	PyModule_AddObject(m, "FloatValue", FloatValue_type);
	return m;
}

