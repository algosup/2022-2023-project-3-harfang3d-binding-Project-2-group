// FABgen output .cpp
// This file is automatically generated, do not modify manually!

#include "fabgen.h"

#include <cstdint>
#include <cassert>
#include <map>
#include <vector>
#include <string>

extern "C" {
#include "lauxlib.h"
#include "lua.h"
}

static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag);
static void *_type_tag_cast(void *in_T0, uint32_t in_type_tag, uint32_t out_type_tag);

typedef struct {
	uint32_t magic_u32; // wrapped_Object marker
	uint32_t type_tag; // wrapped pointer type tag

	void *obj;
	char inline_obj[16]; // storage for inline objects

	void (*on_delete)(void *);
} wrapped_Object;

static void init_wrapped_Object(wrapped_Object *o, uint32_t type_tag, void *obj) {
	o->magic_u32 = 0x46414221;
	o->type_tag = type_tag;

	o->obj = obj;

	o->on_delete = NULL;
}

static wrapped_Object *cast_to_wrapped_Object_safe(lua_State *L, int idx) {
	wrapped_Object *w = (wrapped_Object *)lua_touserdata(L, idx);
	if (!w || w->magic_u32 != 0x46414221)
		return NULL;
	return w;
}

static wrapped_Object *cast_to_wrapped_Object_unsafe(lua_State *L, int idx) { return (wrapped_Object *)lua_touserdata(L, idx); }

static int wrapped_Object_gc(lua_State *L) {
	wrapped_Object *w = cast_to_wrapped_Object_unsafe(L, 1);

	if (w->on_delete)
		w->on_delete(w->obj);

	return 0;
}


// helper class to store a reference to an Lua value on the stack
class LuaValueRef {
public:
	LuaValueRef(lua_State *_L, int idx) : L(_L) {
		lua_pushvalue(L, idx);
		ref = luaL_ref(L, LUA_REGISTRYINDEX);
	}
	~LuaValueRef() {
		if (ref != LUA_NOREF)
			luaL_unref(L, LUA_REGISTRYINDEX, ref);
	}

	void Push() const { lua_rawgeti(L, LUA_REGISTRYINDEX, ref); }

private:
	lua_State *L{nullptr};
	int ref{LUA_NOREF};
};

struct gen_type_info {
	uint32_t type_tag;
	const char *c_type;
	const char *bound_name;

	bool (*check)(lua_State *L, int index);
	void (*to_c)(lua_State *L, int index, void *out);
	int (*from_c)(lua_State *L, void *obj, OwnershipPolicy policy);
};

// return a type info from its type tag
gen_type_info *gen_get_bound_type_info(uint32_t type_tag);
// return a type info from its type name
gen_type_info *gen_get_c_type_info(const char *type);
// returns the typetag of a userdata object on the stack, nullptr if not a Fabgen object
uint32_t gen_get_wrapped_object_type_tag(lua_State *L, int idx);

// bool type tag
static uint32_t type_tag_bool = 0x55813692;

// type API for bool
bool gen_check_bool(lua_State *L, int idx);
void gen_to_c_bool(lua_State *L, int idx, void *obj);
int gen_from_c_bool(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_bool(lua_State *L, int idx) { return lua_isboolean(L, idx) ? true : false; }
void gen_to_c_bool(lua_State *L, int idx, void *obj) { *((bool*)obj) = lua_toboolean(L, idx) == 1; }
int gen_from_c_bool(lua_State *L, void *obj, OwnershipPolicy) { lua_pushboolean(L, *((bool*)obj) ? 1 : 0); return 1; }

// char type tag
static uint32_t type_tag_char = 0x8cfe579f;

// type API for char
bool gen_check_char(lua_State *L, int idx);
void gen_to_c_char(lua_State *L, int idx, void *obj);
int gen_from_c_char(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_char(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_char(lua_State *L, int idx, void *obj) { *((char*)obj) = (char)lua_tointeger(L, idx); }
int gen_from_c_char(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((char*)obj)); return 1; }

// short type tag
static uint32_t type_tag_short = 0x8f2890a2;

// type API for short
bool gen_check_short(lua_State *L, int idx);
void gen_to_c_short(lua_State *L, int idx, void *obj);
int gen_from_c_short(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_short(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_short(lua_State *L, int idx, void *obj) { *((short*)obj) = (short)lua_tointeger(L, idx); }
int gen_from_c_short(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((short*)obj)); return 1; }

// int type tag
static uint32_t type_tag_int = 0x1451dab1;

// type API for int
bool gen_check_int(lua_State *L, int idx);
void gen_to_c_int(lua_State *L, int idx, void *obj);
int gen_from_c_int(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_int(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_int(lua_State *L, int idx, void *obj) { *((int*)obj) = (int)lua_tointeger(L, idx); }
int gen_from_c_int(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((int*)obj)); return 1; }

// long type tag
static uint32_t type_tag_long = 0x3b97a968;

// type API for long
bool gen_check_long(lua_State *L, int idx);
void gen_to_c_long(lua_State *L, int idx, void *obj);
int gen_from_c_long(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_long(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_long(lua_State *L, int idx, void *obj) { *((long*)obj) = (long)lua_tointeger(L, idx); }
int gen_from_c_long(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((long*)obj)); return 1; }

// int8_t type tag
static uint32_t type_tag_int8_t = 0x1c554140;

// type API for int8_t
bool gen_check_int8_t(lua_State *L, int idx);
void gen_to_c_int8_t(lua_State *L, int idx, void *obj);
int gen_from_c_int8_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_int8_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_int8_t(lua_State *L, int idx, void *obj) { *((int8_t*)obj) = (int8_t)lua_tointeger(L, idx); }
int gen_from_c_int8_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((int8_t*)obj)); return 1; }

// int16_t type tag
static uint32_t type_tag_int16_t = 0xbfd40c35;

// type API for int16_t
bool gen_check_int16_t(lua_State *L, int idx);
void gen_to_c_int16_t(lua_State *L, int idx, void *obj);
int gen_from_c_int16_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_int16_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_int16_t(lua_State *L, int idx, void *obj) { *((int16_t*)obj) = (int16_t)lua_tointeger(L, idx); }
int gen_from_c_int16_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((int16_t*)obj)); return 1; }

// int32_t type tag
static uint32_t type_tag_int32_t = 0x12d46c62;

// type API for int32_t
bool gen_check_int32_t(lua_State *L, int idx);
void gen_to_c_int32_t(lua_State *L, int idx, void *obj);
int gen_from_c_int32_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_int32_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_int32_t(lua_State *L, int idx, void *obj) { *((int32_t*)obj) = (int32_t)lua_tointeger(L, idx); }
int gen_from_c_int32_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((int32_t*)obj)); return 1; }

// int64_t type tag
static uint32_t type_tag_int64_t = 0x2187e0e2;

// type API for int64_t
bool gen_check_int64_t(lua_State *L, int idx);
void gen_to_c_int64_t(lua_State *L, int idx, void *obj);
int gen_from_c_int64_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_int64_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_int64_t(lua_State *L, int idx, void *obj) { *((int64_t*)obj) = (int64_t)lua_tointeger(L, idx); }
int gen_from_c_int64_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((int64_t*)obj)); return 1; }

// char16_t type tag
static uint32_t type_tag_char16_t = 0xc19fe7bb;

// type API for char16_t
bool gen_check_char16_t(lua_State *L, int idx);
void gen_to_c_char16_t(lua_State *L, int idx, void *obj);
int gen_from_c_char16_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_char16_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_char16_t(lua_State *L, int idx, void *obj) { *((char16_t*)obj) = (char16_t)lua_tointeger(L, idx); }
int gen_from_c_char16_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((char16_t*)obj)); return 1; }

// char32_t type tag
static uint32_t type_tag_char32_t = 0x6c9f87ec;

// type API for char32_t
bool gen_check_char32_t(lua_State *L, int idx);
void gen_to_c_char32_t(lua_State *L, int idx, void *obj);
int gen_from_c_char32_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_char32_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_char32_t(lua_State *L, int idx, void *obj) { *((char32_t*)obj) = (char32_t)lua_tointeger(L, idx); }
int gen_from_c_char32_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((char32_t*)obj)); return 1; }

// unsigned char type tag
static uint32_t type_tag_unsigned_char = 0x838f8d38;

// type API for unsigned char
bool gen_check_unsigned_char(lua_State *L, int idx);
void gen_to_c_unsigned_char(lua_State *L, int idx, void *obj);
int gen_from_c_unsigned_char(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_unsigned_char(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_unsigned_char(lua_State *L, int idx, void *obj) { *((unsigned char*)obj) = (unsigned char)lua_tointeger(L, idx); }
int gen_from_c_unsigned_char(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((unsigned char*)obj)); return 1; }

// unsigned short type tag
static uint32_t type_tag_unsigned_short = 0xc795d733;

// type API for unsigned short
bool gen_check_unsigned_short(lua_State *L, int idx);
void gen_to_c_unsigned_short(lua_State *L, int idx, void *obj);
int gen_from_c_unsigned_short(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_unsigned_short(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_unsigned_short(lua_State *L, int idx, void *obj) { *((unsigned short*)obj) = (unsigned short)lua_tointeger(L, idx); }
int gen_from_c_unsigned_short(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((unsigned short*)obj)); return 1; }

// unsigned int type tag
static uint32_t type_tag_unsigned_int = 0x657249f8;

// type API for unsigned int
bool gen_check_unsigned_int(lua_State *L, int idx);
void gen_to_c_unsigned_int(lua_State *L, int idx, void *obj);
int gen_from_c_unsigned_int(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_unsigned_int(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_unsigned_int(lua_State *L, int idx, void *obj) { *((unsigned int*)obj) = (unsigned int)lua_tointeger(L, idx); }
int gen_from_c_unsigned_int(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((unsigned int*)obj)); return 1; }

// unsigned long type tag
static uint32_t type_tag_unsigned_long = 0x34e673cf;

// type API for unsigned long
bool gen_check_unsigned_long(lua_State *L, int idx);
void gen_to_c_unsigned_long(lua_State *L, int idx, void *obj);
int gen_from_c_unsigned_long(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_unsigned_long(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_unsigned_long(lua_State *L, int idx, void *obj) { *((unsigned long*)obj) = (unsigned long)lua_tointeger(L, idx); }
int gen_from_c_unsigned_long(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((unsigned long*)obj)); return 1; }

// uint8_t type tag
static uint32_t type_tag_uint8_t = 0x8eabc011;

// type API for uint8_t
bool gen_check_uint8_t(lua_State *L, int idx);
void gen_to_c_uint8_t(lua_State *L, int idx, void *obj);
int gen_from_c_uint8_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_uint8_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_uint8_t(lua_State *L, int idx, void *obj) { *((uint8_t*)obj) = (uint8_t)lua_tointeger(L, idx); }
int gen_from_c_uint8_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((uint8_t*)obj)); return 1; }

// uint16_t type tag
static uint32_t type_tag_uint16_t = 0xa32a93d6;

// type API for uint16_t
bool gen_check_uint16_t(lua_State *L, int idx);
void gen_to_c_uint16_t(lua_State *L, int idx, void *obj);
int gen_from_c_uint16_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_uint16_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_uint16_t(lua_State *L, int idx, void *obj) { *((uint16_t*)obj) = (uint16_t)lua_tointeger(L, idx); }
int gen_from_c_uint16_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((uint16_t*)obj)); return 1; }

// uint32_t type tag
static uint32_t type_tag_uint32_t = 0xe2af381;

// type API for uint32_t
bool gen_check_uint32_t(lua_State *L, int idx);
void gen_to_c_uint32_t(lua_State *L, int idx, void *obj);
int gen_from_c_uint32_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_uint32_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_uint32_t(lua_State *L, int idx, void *obj) { *((uint32_t*)obj) = (uint32_t)lua_tointeger(L, idx); }
int gen_from_c_uint32_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((uint32_t*)obj)); return 1; }

// uint64_t type tag
static uint32_t type_tag_uint64_t = 0x3d797f01;

// type API for uint64_t
bool gen_check_uint64_t(lua_State *L, int idx);
void gen_to_c_uint64_t(lua_State *L, int idx, void *obj);
int gen_from_c_uint64_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_uint64_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_uint64_t(lua_State *L, int idx, void *obj) { *((uint64_t*)obj) = (uint64_t)lua_tointeger(L, idx); }
int gen_from_c_uint64_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((uint64_t*)obj)); return 1; }

// intptr_t type tag
static uint32_t type_tag_intptr_t = 0xc10d8312;

// type API for intptr_t
bool gen_check_intptr_t(lua_State *L, int idx);
void gen_to_c_intptr_t(lua_State *L, int idx, void *obj);
int gen_from_c_intptr_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_intptr_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_intptr_t(lua_State *L, int idx, void *obj) { *((intptr_t*)obj) = (intptr_t)lua_tointeger(L, idx); }
int gen_from_c_intptr_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((intptr_t*)obj)); return 1; }

// size_t type tag
static uint32_t type_tag_size_t = 0x8883767d;

// type API for size_t
bool gen_check_size_t(lua_State *L, int idx);
void gen_to_c_size_t(lua_State *L, int idx, void *obj);
int gen_from_c_size_t(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_size_t(lua_State *L, int idx) { return lua_isinteger(L, idx); }
void gen_to_c_size_t(lua_State *L, int idx, void *obj) { *((size_t*)obj) = (size_t)lua_tointeger(L, idx); }
int gen_from_c_size_t(lua_State *L, void *obj, OwnershipPolicy) { lua_pushinteger(L, *((size_t*)obj)); return 1; }

// float type tag
static uint32_t type_tag_float = 0xc9a55e95;

// type API for float
bool gen_check_float(lua_State *L, int idx);
void gen_to_c_float(lua_State *L, int idx, void *obj);
int gen_from_c_float(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_float(lua_State *L, int idx) { return lua_isnumber(L, idx); }
void gen_to_c_float(lua_State *L, int idx, void *obj) { *((float*)obj) = (float)lua_tonumber(L, idx); }
int gen_from_c_float(lua_State *L, void *obj, OwnershipPolicy) { lua_pushnumber(L, *((float*)obj)); return 1; }

// double type tag
static uint32_t type_tag_double = 0xdae7f2ef;

// type API for double
bool gen_check_double(lua_State *L, int idx);
void gen_to_c_double(lua_State *L, int idx, void *obj);
int gen_from_c_double(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_double(lua_State *L, int idx) { return lua_isnumber(L, idx); }
void gen_to_c_double(lua_State *L, int idx, void *obj) { *((double*)obj) = (double)lua_tonumber(L, idx); }
int gen_from_c_double(lua_State *L, void *obj, OwnershipPolicy) { lua_pushnumber(L, *((double*)obj)); return 1; }

// const char * type tag
static uint32_t type_tag_const_char_ptr = 0x682eed33;

// type API for const char *
struct storage_const_char_ptr;
bool gen_check_const_char_ptr(lua_State *L, int idx);
void gen_to_c_const_char_ptr(lua_State *L, int idx, void *obj, storage_const_char_ptr &storage);
int gen_from_c_const_char_ptr(lua_State *L, void *obj, OwnershipPolicy);

struct storage_const_char_ptr { std::string s; };
bool gen_check_const_char_ptr(lua_State *L, int idx) { return lua_isstring(L, idx); }
void gen_to_c_const_char_ptr(lua_State *L, int idx, void *obj, storage_const_char_ptr &storage) {
	storage.s = lua_tostring(L, idx);
	*((const char **)obj) = storage.s.data();
}
int gen_from_c_const_char_ptr(lua_State *L, void *obj, OwnershipPolicy) { lua_pushstring(L, (*(const char **)obj)); return 1; }

// std::string type tag
static uint32_t type_tag_string = 0x9ebeb2a9;

// type API for std::string
bool gen_check_string(lua_State *L, int idx);
void gen_to_c_string(lua_State *L, int idx, void *obj);
int gen_from_c_string(lua_State *L, void *obj, OwnershipPolicy);

bool gen_check_string(lua_State *L, int idx) { return lua_type(L, idx) == LUA_TSTRING; }
void gen_to_c_string(lua_State *L, int idx, void *obj) { *((std::string*)obj) = lua_tostring(L, idx); }
int gen_from_c_string(lua_State *L, void *obj, OwnershipPolicy) { lua_pushstring(L, ((std::string*)obj)->c_str()); return 1; }

// FloatValue type tag
static uint32_t type_tag_FloatValue = 0x6454579d;

// type API for FloatValue
bool gen_check_FloatValue(lua_State *L, int idx);
void gen_to_c_FloatValue(lua_State *L, int idx, void *obj);
int gen_from_c_FloatValue(lua_State *L, void *obj, OwnershipPolicy);

// FloatValue constructor
static int gen_construct_FloatValue(lua_State *L) {
	lua_remove(L, 1);
	int arg_count = lua_gettop(L), rval_count = 0;

	if (arg_count == 0) {
FloatValue * rval = new FloatValue();
if (!rval) {
lua_pushnil(L);
++rval_count;
} else {
rval_count += gen_from_c_FloatValue(L, (void *)rval, Owning);
}
	} else 	if (arg_count == 1) {
		if (gen_check_float(L, 1)) {
float arg0;
gen_to_c_float(L, 1, &arg0);
FloatValue * rval = new FloatValue(arg0);
if (!rval) {
lua_pushnil(L);
++rval_count;
} else {
rval_count += gen_from_c_FloatValue(L, (void *)rval, Owning);
}
		} else {
return luaL_error(L, "incorrect type for argument 1 to FloatValue constructor, expected float value");
		}
	} else {
return luaL_error(L, "incorrect number of arguments to FloatValue constructor");
	}
	return rval_count;
}

// method Get of FloatValue
static int gen_method_Get_of_FloatValue(lua_State *L) {
	int arg_count = lua_gettop(L) - 1, rval_count = 0;

	if (arg_count == 0) {
	FloatValue * _self;
	gen_to_c_FloatValue(L, 1, &_self);
float rval = _self->Get();
rval_count += gen_from_c_float(L, (void *)&rval, Copy);
	} else {
return luaL_error(L, "incorrect number of arguments to method Get of FloatValue");
	}
	return rval_count;
}

// method Set of FloatValue
static int gen_method_Set_of_FloatValue(lua_State *L) {
	int arg_count = lua_gettop(L) - 1, rval_count = 0;

	if (arg_count == 1) {
		if (gen_check_float(L, 2)) {
	FloatValue * _self;
	gen_to_c_FloatValue(L, 1, &_self);
float arg0;
gen_to_c_float(L, 2, &arg0);
_self->Set(arg0);
		} else {
return luaL_error(L, "incorrect type for argument 1 to method Set of FloatValue, expected float value");
		}
	} else {
return luaL_error(L, "incorrect number of arguments to method Set of FloatValue");
	}
	return rval_count;
}

// + operator of FloatValue
static int gen_add_operator_of_FloatValue(lua_State *L) {
	int arg_count = lua_gettop(L), rval_count = 0;

if (!gen_check_FloatValue(L, 1)) {
return luaL_error(L, "incorrect type for argument 0 to + operator of FloatValue, expected FloatValue");
}

	if (gen_check_FloatValue(L, 2)) {
	FloatValue * _self;
	gen_to_c_FloatValue(L, 1, &_self);
FloatValue * arg0;
gen_to_c_FloatValue(L, 2, &arg0);
FloatValue rval = *_self + *arg0;
rval_count += gen_from_c_FloatValue(L, (void *)&rval, Copy);
	} else {
return luaL_error(L, "incorrect type for argument 1 to + operator of FloatValue, expected FloatValue b");
	}
	return rval_count;
}

static std::map<std::string, int (*)(lua_State *)> __index_member_map_FloatValue = {};

static std::map<std::string, int (*)(lua_State *)> __index_static_member_map_FloatValue = {};

static std::map<std::string, int (*)(lua_State *)> __index_method_map_FloatValue = {
	{"Get", gen_method_Get_of_FloatValue},
	{"Set", gen_method_Set_of_FloatValue}
};

static std::map<std::string, int (*)(lua_State *)> __index_static_method_map_FloatValue = {};

static std::map<std::string, int (*)(lua_State *)> __newindex_member_map_FloatValue = {};

static std::map<std::string, int (*)(lua_State *)> __newindex_static_member_map_FloatValue = {};

static int __index_FloatValue_instance(lua_State *L) {
	if (lua_isstring(L, -1)) {
		std::string key = lua_tostring(L, -1);
		lua_pop(L, 1);

		auto i = __index_member_map_FloatValue.find(key); // member lookup
		if (i != __index_member_map_FloatValue.end())
			return i->second(L);

		i = __index_method_map_FloatValue.find(key); // method lookup
		if (i != __index_method_map_FloatValue.end()) {
			lua_pushcfunction(L, i->second);
			return 1;
		}
	}
	return 0; // lookup failed
}

static int __index_FloatValue_class(lua_State *L) {
	if (lua_isstring(L, -1)) {
		std::string key = lua_tostring(L, -1);
		lua_pop(L, 1);

		auto i = __index_static_member_map_FloatValue.find(key); // member lookup
		if (i != __index_static_member_map_FloatValue.end())
			return i->second(L);

		i = __index_static_method_map_FloatValue.find(key); // method lookup
		if (i != __index_static_method_map_FloatValue.end()) {
			lua_pushcfunction(L, i->second);
			return 1;
		}
	}
	return 0; // lookup failed
}

static int __newindex_FloatValue_instance(lua_State *L) {
	if (lua_isstring(L, -2)) {
		std::string key = lua_tostring(L, -2);
		lua_remove(L, -2);

		auto i = __newindex_member_map_FloatValue.find(key);
		if (i != __newindex_member_map_FloatValue.end())
			return i->second(L);
	}
	return 0; // lookup failed
}

static int __newindex_FloatValue_class(lua_State *L) {
	if (lua_isstring(L, -2)) {
		std::string key = lua_tostring(L, -2);
		lua_remove(L, -2);

		auto i = __newindex_static_member_map_FloatValue.find(key);
		if (i != __newindex_static_member_map_FloatValue.end())
			return i->second(L);
	}
	return 0; // lookup failed
}

static const luaL_Reg FloatValue_class_meta[] = {
	{"__index", __index_FloatValue_class},
	{"__newindex", __newindex_FloatValue_class},
	{"__call", gen_construct_FloatValue},
	{NULL, NULL}};

static int __default_Lua_eq_FloatValue(lua_State *L) {
	wrapped_Object *w1 = cast_to_wrapped_Object_safe(L, -2);
	wrapped_Object *w2 = cast_to_wrapped_Object_safe(L, -1);

	lua_pop(L, 2);

	if (!w1 || !w2 || w1->type_tag != w2->type_tag) {
		lua_pushboolean(L, 0);
		return 1;
	}

	if (!(w1->obj == w2->obj)) {
		lua_pushboolean(L, 0);
		return 1;
	}

	lua_pushboolean(L, 1);
	return 1;
}
static const luaL_Reg FloatValue_instance_meta[] = {
	{"__gc", wrapped_Object_gc},
	{"__index", __index_FloatValue_instance},
	{"__newindex", __newindex_FloatValue_instance},
	{"__eq", __default_Lua_eq_FloatValue},
	{"__add", gen_add_operator_of_FloatValue},
	{NULL, NULL}};

static void register_FloatValue(lua_State *L) {
	// setup class object
	lua_newtable(L); // class object
	lua_newtable(L); // class metatable
	luaL_setfuncs(L, FloatValue_class_meta, 0);
	lua_setmetatable(L, -2);
	lua_setfield(L, -2, "FloatValue");

	// setup type instance metatable
	luaL_newmetatable(L, "FloatValue");
	luaL_setfuncs(L, FloatValue_instance_meta, 0);
	lua_pop(L, 1);
}

static void delete_FloatValue(void *o) { delete (FloatValue *)o; }

bool gen_check_FloatValue(lua_State *L, int idx) {
	wrapped_Object *w = cast_to_wrapped_Object_safe(L, idx);
	if (!w)
		return false;
	return _type_tag_can_cast(w->type_tag, type_tag_FloatValue);
}
void gen_to_c_FloatValue(lua_State *L, int idx, void *obj) {
	wrapped_Object *w = cast_to_wrapped_Object_unsafe(L, idx);
	*(void **)obj = _type_tag_cast(w->obj, w->type_tag, type_tag_FloatValue);
}
int gen_from_c_FloatValue(lua_State *L, void *obj, OwnershipPolicy own) {
	wrapped_Object *w = (wrapped_Object *)lua_newuserdata(L, sizeof(wrapped_Object));
	if (own == Copy)
		obj = new FloatValue(*(FloatValue *)obj);
	init_wrapped_Object(w, type_tag_FloatValue, obj);
	if (own != NonOwning)
		w->on_delete = &delete_FloatValue;
	luaL_setmetatable(L, "FloatValue");
	return 1;
}


// type_tag based cast system
static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag) {
	if (out_type_tag == in_type_tag)
		return true;

	
	return false;
}

static void *_type_tag_cast(void *in_ptr, uint32_t in_type_tag, uint32_t out_type_tag) {
	if (out_type_tag == in_type_tag)
		return in_ptr;

	void *out_ptr = NULL;
	

	return out_ptr;
}

size_t gen_link_binding(gen_type_info *(*get_c_type_info)(const char *type)) {
	size_t unresolved = 0;

	return unresolved;
}

// Note: Types using a storage class for conversion are not listed here.
static std::map<uint32_t, gen_type_info> __type_tag_infos;

static void __initialize_type_tag_infos() {
	__type_tag_infos[type_tag_bool] = {type_tag_bool, "bool", "bool", gen_check_bool, gen_to_c_bool, gen_from_c_bool};
	__type_tag_infos[type_tag_char] = {type_tag_char, "char", "char", gen_check_char, gen_to_c_char, gen_from_c_char};
	__type_tag_infos[type_tag_short] = {type_tag_short, "short", "short", gen_check_short, gen_to_c_short, gen_from_c_short};
	__type_tag_infos[type_tag_int] = {type_tag_int, "int", "int", gen_check_int, gen_to_c_int, gen_from_c_int};
	__type_tag_infos[type_tag_long] = {type_tag_long, "long", "long", gen_check_long, gen_to_c_long, gen_from_c_long};
	__type_tag_infos[type_tag_int8_t] = {type_tag_int8_t, "int8_t", "int8_t", gen_check_int8_t, gen_to_c_int8_t, gen_from_c_int8_t};
	__type_tag_infos[type_tag_int16_t] = {type_tag_int16_t, "int16_t", "int16_t", gen_check_int16_t, gen_to_c_int16_t, gen_from_c_int16_t};
	__type_tag_infos[type_tag_int32_t] = {type_tag_int32_t, "int32_t", "int32_t", gen_check_int32_t, gen_to_c_int32_t, gen_from_c_int32_t};
	__type_tag_infos[type_tag_int64_t] = {type_tag_int64_t, "int64_t", "int64_t", gen_check_int64_t, gen_to_c_int64_t, gen_from_c_int64_t};
	__type_tag_infos[type_tag_char16_t] = {type_tag_char16_t, "char16_t", "char16_t", gen_check_char16_t, gen_to_c_char16_t, gen_from_c_char16_t};
	__type_tag_infos[type_tag_char32_t] = {type_tag_char32_t, "char32_t", "char32_t", gen_check_char32_t, gen_to_c_char32_t, gen_from_c_char32_t};
	__type_tag_infos[type_tag_unsigned_char] = {type_tag_unsigned_char, "unsigned char", "unsigned_char", gen_check_unsigned_char, gen_to_c_unsigned_char, gen_from_c_unsigned_char};
	__type_tag_infos[type_tag_unsigned_short] = {type_tag_unsigned_short, "unsigned short", "unsigned_short", gen_check_unsigned_short, gen_to_c_unsigned_short, gen_from_c_unsigned_short};
	__type_tag_infos[type_tag_unsigned_int] = {type_tag_unsigned_int, "unsigned int", "unsigned_int", gen_check_unsigned_int, gen_to_c_unsigned_int, gen_from_c_unsigned_int};
	__type_tag_infos[type_tag_unsigned_long] = {type_tag_unsigned_long, "unsigned long", "unsigned_long", gen_check_unsigned_long, gen_to_c_unsigned_long, gen_from_c_unsigned_long};
	__type_tag_infos[type_tag_uint8_t] = {type_tag_uint8_t, "uint8_t", "uint8_t", gen_check_uint8_t, gen_to_c_uint8_t, gen_from_c_uint8_t};
	__type_tag_infos[type_tag_uint16_t] = {type_tag_uint16_t, "uint16_t", "uint16_t", gen_check_uint16_t, gen_to_c_uint16_t, gen_from_c_uint16_t};
	__type_tag_infos[type_tag_uint32_t] = {type_tag_uint32_t, "uint32_t", "uint32_t", gen_check_uint32_t, gen_to_c_uint32_t, gen_from_c_uint32_t};
	__type_tag_infos[type_tag_uint64_t] = {type_tag_uint64_t, "uint64_t", "uint64_t", gen_check_uint64_t, gen_to_c_uint64_t, gen_from_c_uint64_t};
	__type_tag_infos[type_tag_intptr_t] = {type_tag_intptr_t, "intptr_t", "intptr_t", gen_check_intptr_t, gen_to_c_intptr_t, gen_from_c_intptr_t};
	__type_tag_infos[type_tag_size_t] = {type_tag_size_t, "size_t", "size_t", gen_check_size_t, gen_to_c_size_t, gen_from_c_size_t};
	__type_tag_infos[type_tag_float] = {type_tag_float, "float", "float", gen_check_float, gen_to_c_float, gen_from_c_float};
	__type_tag_infos[type_tag_double] = {type_tag_double, "double", "double", gen_check_double, gen_to_c_double, gen_from_c_double};
	__type_tag_infos[type_tag_string] = {type_tag_string, "std::string", "string", gen_check_string, gen_to_c_string, gen_from_c_string};
	__type_tag_infos[type_tag_FloatValue] = {type_tag_FloatValue, "FloatValue", "FloatValue", gen_check_FloatValue, gen_to_c_FloatValue, gen_from_c_FloatValue};
};

gen_type_info *gen_get_bound_type_info(uint32_t type_tag) {
	auto i = __type_tag_infos.find(type_tag);
	return i == __type_tag_infos.end() ? nullptr : &i->second;
}

static std::map<std::string, gen_type_info> __type_infos;

static void __initialize_type_infos() {
	__type_infos["bool"] = {type_tag_bool, "bool", "bool", gen_check_bool, gen_to_c_bool, gen_from_c_bool};
	__type_infos["char"] = {type_tag_char, "char", "char", gen_check_char, gen_to_c_char, gen_from_c_char};
	__type_infos["short"] = {type_tag_short, "short", "short", gen_check_short, gen_to_c_short, gen_from_c_short};
	__type_infos["int"] = {type_tag_int, "int", "int", gen_check_int, gen_to_c_int, gen_from_c_int};
	__type_infos["long"] = {type_tag_long, "long", "long", gen_check_long, gen_to_c_long, gen_from_c_long};
	__type_infos["int8_t"] = {type_tag_int8_t, "int8_t", "int8_t", gen_check_int8_t, gen_to_c_int8_t, gen_from_c_int8_t};
	__type_infos["int16_t"] = {type_tag_int16_t, "int16_t", "int16_t", gen_check_int16_t, gen_to_c_int16_t, gen_from_c_int16_t};
	__type_infos["int32_t"] = {type_tag_int32_t, "int32_t", "int32_t", gen_check_int32_t, gen_to_c_int32_t, gen_from_c_int32_t};
	__type_infos["int64_t"] = {type_tag_int64_t, "int64_t", "int64_t", gen_check_int64_t, gen_to_c_int64_t, gen_from_c_int64_t};
	__type_infos["char16_t"] = {type_tag_char16_t, "char16_t", "char16_t", gen_check_char16_t, gen_to_c_char16_t, gen_from_c_char16_t};
	__type_infos["char32_t"] = {type_tag_char32_t, "char32_t", "char32_t", gen_check_char32_t, gen_to_c_char32_t, gen_from_c_char32_t};
	__type_infos["unsigned char"] = {type_tag_unsigned_char, "unsigned char", "unsigned_char", gen_check_unsigned_char, gen_to_c_unsigned_char, gen_from_c_unsigned_char};
	__type_infos["unsigned short"] = {type_tag_unsigned_short, "unsigned short", "unsigned_short", gen_check_unsigned_short, gen_to_c_unsigned_short, gen_from_c_unsigned_short};
	__type_infos["unsigned int"] = {type_tag_unsigned_int, "unsigned int", "unsigned_int", gen_check_unsigned_int, gen_to_c_unsigned_int, gen_from_c_unsigned_int};
	__type_infos["unsigned long"] = {type_tag_unsigned_long, "unsigned long", "unsigned_long", gen_check_unsigned_long, gen_to_c_unsigned_long, gen_from_c_unsigned_long};
	__type_infos["uint8_t"] = {type_tag_uint8_t, "uint8_t", "uint8_t", gen_check_uint8_t, gen_to_c_uint8_t, gen_from_c_uint8_t};
	__type_infos["uint16_t"] = {type_tag_uint16_t, "uint16_t", "uint16_t", gen_check_uint16_t, gen_to_c_uint16_t, gen_from_c_uint16_t};
	__type_infos["uint32_t"] = {type_tag_uint32_t, "uint32_t", "uint32_t", gen_check_uint32_t, gen_to_c_uint32_t, gen_from_c_uint32_t};
	__type_infos["uint64_t"] = {type_tag_uint64_t, "uint64_t", "uint64_t", gen_check_uint64_t, gen_to_c_uint64_t, gen_from_c_uint64_t};
	__type_infos["intptr_t"] = {type_tag_intptr_t, "intptr_t", "intptr_t", gen_check_intptr_t, gen_to_c_intptr_t, gen_from_c_intptr_t};
	__type_infos["size_t"] = {type_tag_size_t, "size_t", "size_t", gen_check_size_t, gen_to_c_size_t, gen_from_c_size_t};
	__type_infos["float"] = {type_tag_float, "float", "float", gen_check_float, gen_to_c_float, gen_from_c_float};
	__type_infos["double"] = {type_tag_double, "double", "double", gen_check_double, gen_to_c_double, gen_from_c_double};
	__type_infos["std::string"] = {type_tag_string, "std::string", "string", gen_check_string, gen_to_c_string, gen_from_c_string};
	__type_infos["FloatValue"] = {type_tag_FloatValue, "FloatValue", "FloatValue", gen_check_FloatValue, gen_to_c_FloatValue, gen_from_c_FloatValue};
};


gen_type_info *gen_get_c_type_info(const char *type) {
	auto i = __type_infos.find(type);
	return i == __type_infos.end() ? nullptr : &i->second;
}

uint32_t gen_get_wrapped_object_type_tag(lua_State *L, int idx) {
	auto o = cast_to_wrapped_Object_safe(L, idx);
	return o ? o->type_tag : 0;
}

static const luaL_Reg float_value_global_functions[] = {
	{NULL, NULL}};

#if WIN32
 #define _DLL_EXPORT_ __declspec(dllexport)
#else
 #define _DLL_EXPORT_
#endif

static void declare_enum_value(lua_State *L, int idx, const char *name, int value) {
	lua_pushinteger(L, value);
	lua_setfield(L, idx, name);
}

static std::map<std::string, int (*)(lua_State *)> __index_float_value_var_map = {};

static std::map<std::string, int (*)(lua_State *)> __newindex_float_value_var_map = {};

static int __index_float_value_var(lua_State *L) {
	if (lua_isstring(L, -1)) {
		std::string key = lua_tostring(L, -1);
		lua_pop(L, 1);

		auto i = __index_float_value_var_map.find(key); // variable lookup
		if (i != __index_float_value_var_map.end())
			return i->second(L);
	}
	return 0; // lookup failed
}

static int __newindex_float_value_var(lua_State *L) {
	if (lua_isstring(L, -2)) {
		std::string key = lua_tostring(L, -2);
		lua_remove(L, -2);

		auto i = __newindex_float_value_var_map.find(key);
		if (i != __newindex_float_value_var_map.end())
			return i->second(L);
	}
	return 0; // lookup failed
}

static int __gc_float_value(lua_State *L) {
	// custom free code
   return 0;
}

static const luaL_Reg float_value_module_meta[] = {
	{"__gc", __gc_float_value},
	{"__index", __index_float_value_var},
	{"__newindex", __newindex_float_value_var},
	{NULL, NULL}
};

extern "C" _DLL_EXPORT_ int luaopen_float_value(lua_State *L) {
	// initialize type info structures
	__initialize_type_tag_infos();
	__initialize_type_infos();

	// custom initialization code

	// new module table
	lua_newtable(L);

	// register types
	register_FloatValue(L);

	// register global functions
	luaL_setfuncs(L, float_value_global_functions, 0);

	// setup module metatable
	lua_newtable(L);
	luaL_setfuncs(L, float_value_module_meta, 0);
	lua_setmetatable(L, -2);
	return 1;
}

