// FABgen output .h
// This file is automatically generated, do not modify manually!

#pragma once

#include <cstdint>

#include <cstddef>

struct lua_State;

struct gen_type_info {
	uint32_t type_tag;
	const char *c_type;
	const char *bound_name;

	bool (*check)(lua_State *L, int index);
	void (*to_c)(lua_State *L, int index, void *out);
	int (*from_c)(lua_State *L, void *obj, OwnershipPolicy policy);
};

// return a type info from its type tag
gen_type_info *gen_get_bound_type_info(uint32_t type_tag);
// return a type info from its type name
gen_type_info *gen_get_c_type_info(const char *type);
// returns the typetag of a userdata object on the stack, nullptr if not a Fabgen object
uint32_t gen_get_wrapped_object_type_tag(lua_State *L, int idx);

// type API for bool
bool gen_check_bool(lua_State *L, int idx);
void gen_to_c_bool(lua_State *L, int idx, void *obj);
int gen_from_c_bool(lua_State *L, void *obj, OwnershipPolicy);

// type API for char
bool gen_check_char(lua_State *L, int idx);
void gen_to_c_char(lua_State *L, int idx, void *obj);
int gen_from_c_char(lua_State *L, void *obj, OwnershipPolicy);

// type API for short
bool gen_check_short(lua_State *L, int idx);
void gen_to_c_short(lua_State *L, int idx, void *obj);
int gen_from_c_short(lua_State *L, void *obj, OwnershipPolicy);

// type API for int
bool gen_check_int(lua_State *L, int idx);
void gen_to_c_int(lua_State *L, int idx, void *obj);
int gen_from_c_int(lua_State *L, void *obj, OwnershipPolicy);

// type API for long
bool gen_check_long(lua_State *L, int idx);
void gen_to_c_long(lua_State *L, int idx, void *obj);
int gen_from_c_long(lua_State *L, void *obj, OwnershipPolicy);

// type API for int8_t
bool gen_check_int8_t(lua_State *L, int idx);
void gen_to_c_int8_t(lua_State *L, int idx, void *obj);
int gen_from_c_int8_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for int16_t
bool gen_check_int16_t(lua_State *L, int idx);
void gen_to_c_int16_t(lua_State *L, int idx, void *obj);
int gen_from_c_int16_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for int32_t
bool gen_check_int32_t(lua_State *L, int idx);
void gen_to_c_int32_t(lua_State *L, int idx, void *obj);
int gen_from_c_int32_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for int64_t
bool gen_check_int64_t(lua_State *L, int idx);
void gen_to_c_int64_t(lua_State *L, int idx, void *obj);
int gen_from_c_int64_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for char16_t
bool gen_check_char16_t(lua_State *L, int idx);
void gen_to_c_char16_t(lua_State *L, int idx, void *obj);
int gen_from_c_char16_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for char32_t
bool gen_check_char32_t(lua_State *L, int idx);
void gen_to_c_char32_t(lua_State *L, int idx, void *obj);
int gen_from_c_char32_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for unsigned char
bool gen_check_unsigned_char(lua_State *L, int idx);
void gen_to_c_unsigned_char(lua_State *L, int idx, void *obj);
int gen_from_c_unsigned_char(lua_State *L, void *obj, OwnershipPolicy);

// type API for unsigned short
bool gen_check_unsigned_short(lua_State *L, int idx);
void gen_to_c_unsigned_short(lua_State *L, int idx, void *obj);
int gen_from_c_unsigned_short(lua_State *L, void *obj, OwnershipPolicy);

// type API for unsigned int
bool gen_check_unsigned_int(lua_State *L, int idx);
void gen_to_c_unsigned_int(lua_State *L, int idx, void *obj);
int gen_from_c_unsigned_int(lua_State *L, void *obj, OwnershipPolicy);

// type API for unsigned long
bool gen_check_unsigned_long(lua_State *L, int idx);
void gen_to_c_unsigned_long(lua_State *L, int idx, void *obj);
int gen_from_c_unsigned_long(lua_State *L, void *obj, OwnershipPolicy);

// type API for uint8_t
bool gen_check_uint8_t(lua_State *L, int idx);
void gen_to_c_uint8_t(lua_State *L, int idx, void *obj);
int gen_from_c_uint8_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for uint16_t
bool gen_check_uint16_t(lua_State *L, int idx);
void gen_to_c_uint16_t(lua_State *L, int idx, void *obj);
int gen_from_c_uint16_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for uint32_t
bool gen_check_uint32_t(lua_State *L, int idx);
void gen_to_c_uint32_t(lua_State *L, int idx, void *obj);
int gen_from_c_uint32_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for uint64_t
bool gen_check_uint64_t(lua_State *L, int idx);
void gen_to_c_uint64_t(lua_State *L, int idx, void *obj);
int gen_from_c_uint64_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for intptr_t
bool gen_check_intptr_t(lua_State *L, int idx);
void gen_to_c_intptr_t(lua_State *L, int idx, void *obj);
int gen_from_c_intptr_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for size_t
bool gen_check_size_t(lua_State *L, int idx);
void gen_to_c_size_t(lua_State *L, int idx, void *obj);
int gen_from_c_size_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for float
bool gen_check_float(lua_State *L, int idx);
void gen_to_c_float(lua_State *L, int idx, void *obj);
int gen_from_c_float(lua_State *L, void *obj, OwnershipPolicy);

// type API for double
bool gen_check_double(lua_State *L, int idx);
void gen_to_c_double(lua_State *L, int idx, void *obj);
int gen_from_c_double(lua_State *L, void *obj, OwnershipPolicy);

// type API for const char *
struct storage_const_char_ptr;
bool gen_check_const_char_ptr(lua_State *L, int idx);
void gen_to_c_const_char_ptr(lua_State *L, int idx, void *obj, storage_const_char_ptr &storage);
int gen_from_c_const_char_ptr(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::string
bool gen_check_string(lua_State *L, int idx);
void gen_to_c_string(lua_State *L, int idx, void *obj);
int gen_from_c_string(lua_State *L, void *obj, OwnershipPolicy);

// type API for FloatValue
bool gen_check_FloatValue(lua_State *L, int idx);
void gen_to_c_FloatValue(lua_State *L, int idx, void *obj);
int gen_from_c_FloatValue(lua_State *L, void *obj, OwnershipPolicy);

/*
	pass the get_c_type_info function from another binding to this function to resolve external types declared in this binding.
	you will need to write a wrapper to cast the type_info * pointer to the correct type if you are using a binding prefix.
	this function returns the number of unresolved external symbols.
*/
size_t gen_link_binding(gen_type_info *(*get_c_type_info)(const char *));

